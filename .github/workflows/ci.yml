name: CI - cross-build
permissions:
  contents: write

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      public_repo:
        description: "Optional public repository URL to clone (git). Leave empty to skip."
        required: false
        default: ""

jobs:
  build-matrix:
    name: Build (${{ matrix.name }})
    runs-on: ${{ matrix.runs-on }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: windows-x86_64
            runs-on: windows-latest
          - name: mac-arm64
            runs-on: macos-latest
          - name: linux-x86_64
            runs-on: ubuntu-latest

    env:
      CMAKE_BUILD_TYPE: "Release"
      CMAKE_CXX_STANDARD: "17"
      CMAKE_CXX_STANDARD_REQUIRED: "ON"
      CMAKE_CXX_EXTENSIONS: "OFF"
      CMAKE_POLICY_VERSION_MINIMUM: "3.5"
      CMAKE_OSX_ARCHITECTURES: "arm64"
      MATRIX_BUILD_CMD: "cmake --build build --parallel"

    steps:
      - name: Checkout repository (uses git)
        uses: actions/checkout@v4

      - name: Configure with CMake (Windows, use preinstalled GCC)
        if: matrix.name == 'windows-x86_64'
        shell: pwsh
        run: |
          Write-Host "Configuring with preinstalled GCC and Ninja on Windows"
          # build argument array: basic args
          $args = @('-S', 'parsers/cpp', '-B', 'build', '-G', 'Ninja')
          # append environment CMAKE_* defs
          Get-ChildItem env:CMAKE_* | ForEach-Object { $args += "-D$($_.Name)=$($_.Value)" }
          # set compilers explicitly to the preinstalled gcc/g++
          $args += '-DCMAKE_C_COMPILER=gcc'
          $args += '-DCMAKE_CXX_COMPILER=g++'
          Write-Host "Running: cmake $($args -join ' ')"
          & cmake @args

      - name: Build (Windows using preinstalled GCC/Ninja)
        if: matrix.name == 'windows-x86_64'
        shell: pwsh
        run: |
          Write-Host "Building with Ninja using preinstalled GCC"
          cmake --build build --parallel

      - name: Configure with CMake (macOS/Linux)
        if: matrix.name != 'windows-x86_64'
        shell: bash
        run: |
          echo "Environment CMake vars:"
          env | grep '^CMAKE_' || true
          CMDEF_ARGS=""
          while IFS='=' read -r name val; do
            CMDEF_ARGS+=" -D${name}='${val}'"
          done < <(env | grep '^CMAKE_')
          echo "Invoking: cmake -S parsers/cpp -B build ${CMDEF_ARGS}"
          eval cmake -S parsers/cpp -B build ${CMDEF_ARGS}
        env: {}

      - name: Build (mac-arm64)
        if: matrix.name == 'mac-arm64'
        shell: bash
        run: |
          echo "Ensuring CMake policy flags are applied and building"
          cmake --build build -- -j$(sysctl -n hw.logicalcpu)

      - name: Build (linux-x86_64)
        if: matrix.name == 'linux-x86_64'
        shell: bash
        run: |
          cmake --build build -- -j$(nproc)

      - name: List build output (Linux/macOS)
        if: matrix.name != 'windows-x86_64'
        shell: bash
        run: |
          echo "Build tree contents:"
          ls -la build || true

      - name: List build output (Windows)
        if: matrix.name == 'windows-x86_64'
        shell: pwsh
        run: |
          Write-Host "Build tree contents:"
          if (Test-Path -Path build) {
            Get-ChildItem -Path build -Recurse | ForEach-Object { Write-Host $_.FullName }
          } else {
            Write-Host "No build directory"
          }

      - name: Upload build artifacts (optional)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ matrix.name }}
          path: build

  create-release:
    name: Create Release and upload assets
    runs-on: ubuntu-latest
    needs: build-matrix
    steps:
      - name: Checkout (required for some actions)
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4

      - name: Prepare release assets
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p release
          # artifacts are downloaded as directories named like build-<matrix.name>
          for d in build-*; do
            [ -d "$d" ] || continue
            base=$(basename "$d")
            name=${base#build-}
            os=$(echo "$name" | cut -d'-' -f1)
            arch=$(echo "$name" | cut -d'-' -f2-)

            bin=""
            if [[ "$os" == "windows" ]]; then
              bin=$(find "$d" -type f -iname 'logparser.exe' -print -quit || true)
            else
              bin=$(find "$d" -type f -name 'logparser' -print -quit || true)
            fi

            if [ -z "$bin" ]; then
              bin=$(find "$d" -type f -perm -u=x -print -quit || true)
            fi

            if [ -z "$bin" ]; then
              bin=$(find "$d" -type f -print0 | xargs -0 file 2>/dev/null | grep -E 'ELF|Mach-O|PE32' | cut -d: -f1 | head -n1 || true)
            fi

            if [ -n "$bin" ]; then
              if [[ "$os" == "windows" ]]; then
                # Attempt to locate libantlr4-runtime.dll inside the artifact
                dllpath="$d/antlr4_runtime/src/antlr4_runtime/runtime/Cpp/dist/libantlr4-runtime.dll"
                if [ ! -f "$dllpath" ]; then
                  # fallback: search within the artifact for a file named libantlr4-runtime.dll
                  dllpath=$(find "$d" -type f -iname 'libantlr4-runtime.dll' -print -quit || true)
                fi

                if [ -n "$dllpath" ]; then
                  zipdest=release/logparser-${os}-${arch}.zip
                  rm -f "$zipdest"
                  # include the exe and the dll
                  zip -j "$zipdest" "$bin" "$dllpath"
                  echo "Created $zipdest containing $bin and $dllpath"
                else
                  # no dll found, fall back to copying the exe
                  dest=release/logparser-${os}-${arch}.exe
                  cp "$bin" "$dest"
                  echo "Copied $bin -> $dest (no DLL found)"
                fi
              else
                dest=release/logparser-${os}-${arch}
                cp "$bin" "$dest"
                echo "Copied $bin -> $dest"
              fi
            else
              echo "No logparser binary found in $d"
            fi
          done

      - id: set_short_sha
        name: Set SHORT_SHA
        shell: bash
        run: |
          SHORT_SHA=${GITHUB_SHA::7}
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT

      - name: Create Release and upload assets
        uses: softprops/action-gh-release@v1
        with:
          tag_name: release-${{ steps.set_short_sha.outputs.short_sha }}
          name: "ðŸ”– ${{ steps.set_short_sha.outputs.short_sha }} | Release"
          files: |
            release/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
